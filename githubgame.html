<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Block Stacking Game</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa">
    <style>
        :root {
            --color-dark: #5A67D8; /* Soft indigo for a modern, aesthetic vibe */
        }

        html, body {
            margin: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            position: relative;
            font-family: 'Comfortaa', cursive;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /* Aesthetic gradient background */
            touch-action: none; /* Prevent default touch behaviors for better game control */
        }

        #container {
            width: 100%;
            height: 100%;
        }

        #container #score {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: clamp(4vh, 8vw, 10vh); /* Responsive font size for mobile */
            transition: transform 0.5s ease;
            color: #ffffff; /* White text for contrast on gradient */
            text-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow for readability */
            transform: translatey(-200px) scale(1);
            z-index: 10;
        }

        #container #game {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }
        
        #container .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 85%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        #container .game-over * {
            transition: opacity 0.5s ease, transform 0.5s ease;
            opacity: 0;
            transform: translatey(-50px);
            color: #ffffff; /* White for aesthetic pop */
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            text-align: center;
        }
        
        #container .game-over h2 {
            margin: 0;
            padding: 0;
            font-size: clamp(2rem, 5vw, 2.5rem); /* Responsive heading */
        }

        #container .game-over p {
            font-size: clamp(1rem, 3vw, 1.2rem); /* Responsive text */
            margin: 0.5rem 0;
        }

        #container .game-ready {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-around;
            z-index: 10;
        }
        
        #container .game-ready #start-button {
            transition: opacity 0.5s ease, transform 0.5s ease;
            opacity: 0;
            transform: translatey(-50px);
            
            border: 3px solid #ffffff; /* White border for clean look */
            padding: clamp(8px, 2vw, 10px) clamp(16px, 4vw, 20px); /* Responsive padding */
            background-color: rgba(255,255,255,0.1); /* Semi-transparent white bg */
            color: #ffffff;
            font-size: clamp(1.2rem, 4vw, 1.5rem); /* Responsive button text */
            border-radius: 8px; /* Rounded corners for modern feel */
            backdrop-filter: blur(10px); /* Subtle blur for glassmorphism */
            cursor: pointer;
            user-select: none;
            touch-action: manipulation; /* Optimize for touch */
        }

        #container .game-ready #start-button:active {
            transform: scale(0.95); /* Subtle press effect for touch/click */
        }

        #container #instructions {
            position: absolute;
            width: 100%;
            top: 16vh;
            left: 0;
            text-align: center;
            transition: opacity 0.5s ease, transform 0.5s ease;
            
            opacity: 0;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: clamp(0.8rem, 2.5vw, 1rem); /* Responsive instructions */
            padding: 0 1rem;
            z-index: 10;
        }
        
        #container #instructions.hide {
            opacity: 0 !important;
        }
        
        #container.playing, #container.resetting #score {
            transform: translatey(0px) scale(1);
        }
        
        #container.playing #instructions {
            opacity: 1;
        }
        
        #container.ready .game-ready #start-button {
            opacity: 1;
            transform: translatey(0);
        }
        
        #container.ended #score {
            transform: translatey(6vh) scale(1.5);
        }
        
        #container.ended .game-over * {
            opacity: 1;
            transform: translatey(0);
        }
        
        #container.ended .game-over p {
            transition-delay: 0.3s;
        }

        /* Media queries for finer mobile adjustments */
        @media (max-width: 480px) {
            #container #instructions {
                top: 12vh; /* Adjust position on small screens */
            }
            
            #container .game-over {
                height: 90%; /* More space on small screens */
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
</head>
<body>
    <div id="container">
        <div id="game"></div>
        <div id="score">0</div>
        <div id="instructions">Tap (or press the spacebar) to place the block</div> <!-- Updated text for mobile -->
        <div class="game-over">
            <h2>Game Over</h2>
            <p>You did great, you're the best.</p>
            <p>Tap or spacebar to start again</p> <!-- Updated for mobile -->
        </div>
        <div class="game-ready">
            <div id="start-button">Start</div>
            <div></div>
        </div>
    </div>
    <script>
        // Converted TypeScript-like code to plain JavaScript
        // Removed type annotations, interfaces, and fixed class statics/consts
        // Updated colors for aesthetic: softer, pastel-like dynamic colors
        // Mobile improvements: Fixed touch handling, responsive elements

        console.clear();

        // BlockReturn "interface" simulated as a comment
        /*
        BlockReturn {
            placed?: any;
            chopped?: any;
            plane: 'x' | 'y' | 'z';
            direction: number;
            bonus?: boolean;
        }
        */

        class Stage {
            constructor() {
                // container
                this.container = document.getElementById('game');
                
                // renderer - Optimized for mobile: lower antialias if needed, but keep for quality
                this.renderer = new THREE.WebGLRenderer({
                    antialias: window.innerWidth > 768, // Disable antialias on small screens for perf
                    alpha: true // Alpha true to blend with gradient bg
                });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0); // Transparent clear for gradient
                this.renderer.domElement.style.touchAction = 'none'; // Prevent scrolling on touch
                this.container.appendChild(this.renderer.domElement);
                
                // scene
                this.scene = new THREE.Scene();

                // camera
                let aspect = window.innerWidth / window.innerHeight;
                let d = 20;
                this.camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, -100, 1000);
                this.camera.position.x = 2;
                this.camera.position.y = 2; 
                this.camera.position.z = 2; 
                this.camera.lookAt(new THREE.Vector3(0, 0, 0));
                
                // light - softer, warmer tones
                this.light = new THREE.DirectionalLight(0xE2E8F0, 0.6); // Light slate
                this.light.position.set(0, 499, 0);
                this.scene.add(this.light);

                this.softLight = new THREE.AmbientLight(0xF7FAFC, 0.5); // Very light blue-gray
                this.scene.add(this.softLight);
                
                window.addEventListener('resize', () => this.onResize());
                this.onResize();
            }
            
            setCamera(y, speed = 0.3) {
                gsap.to(this.camera.position, {duration: speed, y: y + 4, ease: "power1.inOut"});
                gsap.to(this.camera.lookAt, {duration: speed, y: y, ease: "power1.inOut"});
            }
            
            onResize() {
                let viewSize = 30;
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.camera.left = window.innerWidth / -viewSize;
                this.camera.right = window.innerWidth / viewSize;
                this.camera.top = window.innerHeight / viewSize;
                this.camera.bottom = window.innerHeight / -viewSize;
                this.camera.updateProjectionMatrix();
                // Force repaint on resize for mobile
                if (this.renderer) this.renderer.render(this.scene, this.camera);
            }
            
            render() {
                this.renderer.render(this.scene, this.camera);
            }

            add(elem) {
                this.scene.add(elem);
            }

            remove(elem) {
                this.scene.remove(elem);
            }
        }

        class Block {
            STATES = {ACTIVE: 'active', STOPPED: 'stopped', MISSED: 'missed'};
            MOVE_AMOUNT = 12;

            dimension = { width: 0, height: 0, depth: 0 };
            position = {x: 0, y: 0, z: 0};
            
            mesh = null;
            state = '';
            index = 0;
            speed = 0;
            direction = 0;
            colorOffset = 0;
            color = 0;
            material = null;

            workingPlane = '';
            workingDimension = '';

            targetBlock = null;
            
            constructor(block) {
                // set size and position
                this.targetBlock = block;
                
                this.index = (this.targetBlock ? this.targetBlock.index : 0) + 1;
                this.workingPlane = this.index % 2 ? 'x' : 'z';
                this.workingDimension = this.index % 2 ? 'width' : 'depth';
                
                // set the dimensions from the target block, or defaults.
                this.dimension.width = this.targetBlock ? this.targetBlock.dimension.width : 10;
                this.dimension.height = this.targetBlock ? this.targetBlock.dimension.height : 2;
                this.dimension.depth = this.targetBlock ? this.targetBlock.dimension.depth : 10;
                
                this.position.x = this.targetBlock ? this.targetBlock.position.x : 0;
                this.position.y = this.dimension.height * this.index;
                this.position.z = this.targetBlock ? this.targetBlock.position.z : 0;
                
                this.colorOffset = this.targetBlock ? this.targetBlock.colorOffset : Math.round(Math.random() * 100);
                
                // set color - adjusted for softer pastels
                if (!this.targetBlock) {
                    this.color = 0x5A67D8; // Soft indigo base
                } else {
                    let offset = this.index + this.colorOffset;
                    // Shifted to pastel range: 180-240 base, smaller sin amplitude for subtlety
                    var r = Math.sin(0.3 * offset + 0) * 30 + 180; // Softer red
                    var g = Math.sin(0.3 * offset + 2) * 40 + 200; // Softer green
                    var b = Math.sin(0.3 * offset + 4) * 35 + 220; // Softer blue
                    this.color = new THREE.Color(r / 255, g / 255, b / 255);
                }
                
                // state
                this.state = this.index > 1 ? this.STATES.ACTIVE : this.STATES.STOPPED;
                
                // set direction - Slightly slower on mobile for easier timing?
                this.speed = -0.1 - (this.index * 0.005);
                if (this.speed < -4) this.speed = -4;
                this.direction = this.speed;
                
                // create block
                let geometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
                geometry.applyMatrix(new THREE.Matrix4().makeTranslation(this.dimension.width / 2, this.dimension.height / 2, this.dimension.depth / 2));
                this.material = new THREE.MeshToonMaterial({color: this.color, shading: THREE.FlatShading});
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.mesh.position.set(this.position.x, this.position.y + (this.state == this.STATES.ACTIVE ? 0 : 0), this.position.z);
                
                if (this.state == this.STATES.ACTIVE) {
                    this.position[this.workingPlane] = Math.random() > 0.5 ? -this.MOVE_AMOUNT : this.MOVE_AMOUNT;
                }
            } 

            reverseDirection() {
                this.direction = this.direction > 0 ? this.speed : Math.abs(this.speed); 	
            }

            place() {
                this.state = this.STATES.STOPPED;
                
                let overlap = this.targetBlock.dimension[this.workingDimension] - Math.abs(this.position[this.workingPlane] - this.targetBlock.position[this.workingPlane]);
                
                let blocksToReturn = {
                    plane: this.workingPlane,
                    direction: this.direction
                };
                
                if (this.dimension[this.workingDimension] - overlap < 0.3) {
                    overlap = this.dimension[this.workingDimension];
                    blocksToReturn.bonus = true;
                    this.position.x = this.targetBlock.position.x;
                    this.position.z = this.targetBlock.position.z;
                    this.dimension.width = this.targetBlock.dimension.width;
                    this.dimension.depth = this.targetBlock.dimension.depth;
                }
                
                if (overlap > 0) {
                    let choppedDimensions = { width: this.dimension.width, height: this.dimension.height, depth: this.dimension.depth };
                    choppedDimensions[this.workingDimension] -= overlap;
                    this.dimension[this.workingDimension] = overlap;
                            
                    let placedGeometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
                    placedGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(this.dimension.width / 2, this.dimension.height / 2, this.dimension.depth / 2));
                    let placedMesh = new THREE.Mesh(placedGeometry, this.material);
                    
                    let choppedGeometry = new THREE.BoxGeometry(choppedDimensions.width, choppedDimensions.height, choppedDimensions.depth);
                    choppedGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(choppedDimensions.width / 2, choppedDimensions.height / 2, choppedDimensions.depth / 2));
                    let choppedMesh = new THREE.Mesh(choppedGeometry, this.material);
                    
                    let choppedPosition = {
                        x: this.position.x,
                        y: this.position.y,
                        z: this.position.z
                    }
                    
                    if (this.position[this.workingPlane] < this.targetBlock.position[this.workingPlane]) {
                        this.position[this.workingPlane] = this.targetBlock.position[this.workingPlane]
                    } else {
                        choppedPosition[this.workingPlane] += overlap;
                    }
                    
                    placedMesh.position.set(this.position.x, this.position.y, this.position.z);
                    choppedMesh.position.set(choppedPosition.x, choppedPosition.y, choppedPosition.z);
                    
                    blocksToReturn.placed = placedMesh;
                    if (!blocksToReturn.bonus) blocksToReturn.chopped = choppedMesh;
                } else {
                    this.state = this.STATES.MISSED;
                }
                
                this.dimension[this.workingDimension] = overlap;

                return blocksToReturn;
            }
            
            tick() {
                if (this.state == this.STATES.ACTIVE) {
                    let value = this.position[this.workingPlane];
                    if (value > this.MOVE_AMOUNT || value < -this.MOVE_AMOUNT) this.reverseDirection();
                    this.position[this.workingPlane] += this.direction;	
                    this.mesh.position[this.workingPlane] = this.position[this.workingPlane];	
                }
            }
        }

        class Game {
            STATES = {
                'LOADING': 'loading',
                'PLAYING': 'playing',
                'READY': 'ready',
                'ENDED': 'ended',
                'RESETTING': 'resetting'
            };
            blocks = [];
            state = this.STATES.LOADING;
            
            // groups
            newBlocks = null;
            placedBlocks = null;
            choppedBlocks = null;

            // UI elements
            scoreContainer = null;
            mainContainer = null;
            startButton = null;
            instructions = null;
            stage = null;
            
            constructor() {
                this.stage = new Stage();
                
                this.mainContainer = document.getElementById('container');
                this.scoreContainer = document.getElementById('score');
                this.startButton = document.getElementById('start-button');
                this.instructions = document.getElementById('instructions');
                this.scoreContainer.innerHTML = '0';
                
                this.newBlocks = new THREE.Group();
                this.placedBlocks = new THREE.Group();
                this.choppedBlocks = new THREE.Group();
                
                this.stage.add(this.newBlocks);
                this.stage.add(this.placedBlocks);
                this.stage.add(this.choppedBlocks);
                
                this.addBlock();
                this.tick();
                
                this.updateState(this.STATES.READY);
                
                // Event listeners - Improved for mobile
                document.addEventListener('keydown', e => {
                    if (e.keyCode == 32) {
                        e.preventDefault(); // Prevent spacebar scroll
                        this.onAction();
                    }
                });
                
                // Click and touch events with debouncing to prevent double-fire on mobile
                let actionTimeout;
                const handleAction = (e) => {
                    if (actionTimeout) return;
                    actionTimeout = setTimeout(() => { actionTimeout = null; }, 300); // 300ms debounce
                    e.preventDefault();
                    this.onAction();
                };
                
                document.addEventListener('click', handleAction);
                
                document.addEventListener('touchstart', handleAction, { passive: false });
                
                // Tap feedback for start button
                this.startButton.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                });
            }

            updateState(newState) {
                for (let key in this.STATES) this.mainContainer.classList.remove(this.STATES[key]);
                this.mainContainer.classList.add(newState);
                this.state = newState;
            }

            onAction() {
                switch (this.state) {
                    case this.STATES.READY:
                        this.startGame();
                        break;
                    case this.STATES.PLAYING:
                        this.placeBlock();
                        break;
                    case this.STATES.ENDED:
                        this.restartGame();
                        break;	
                }
            }
            
            startGame() {
                if (this.state != this.STATES.PLAYING) {
                    this.scoreContainer.innerHTML = '0';
                    this.updateState(this.STATES.PLAYING);
                    this.addBlock();
                }
            }

            restartGame() {
                this.updateState(this.STATES.RESETTING);
                
                let oldBlocks = this.placedBlocks.children;
                let removeSpeed = 0.2;
                let delayAmount = 0.02;
                for (let i = 0; i < oldBlocks.length; i++) {
                    gsap.to(oldBlocks[i].scale, {duration: removeSpeed, x: 0, y: 0, z: 0, delay: (oldBlocks.length - i) * delayAmount, ease: "power1.in", onComplete: () => this.placedBlocks.remove(oldBlocks[i])});
                    gsap.to(oldBlocks[i].rotation, {duration: removeSpeed, y: 0.5, delay: (oldBlocks.length - i) * delayAmount, ease: "power1.in"});
                }
                let cameraMoveSpeed = removeSpeed * 2 + (oldBlocks.length * delayAmount);
                this.stage.setCamera(2, cameraMoveSpeed);
                
                let countdown = {value: this.blocks.length - 1};
                gsap.to(countdown, {duration: cameraMoveSpeed, value: 0, onUpdate: () => {this.scoreContainer.innerHTML = String(Math.round(countdown.value))}});
                
                this.blocks = this.blocks.slice(0, 1);
                
                setTimeout(() => {
                    this.startGame();
                }, cameraMoveSpeed * 1000);
                
            }
            
            placeBlock() {
                let currentBlock = this.blocks[this.blocks.length - 1];
                let newBlocks = currentBlock.place();
                this.newBlocks.remove(currentBlock.mesh);
                if (newBlocks.placed) this.placedBlocks.add(newBlocks.placed);
                if (newBlocks.chopped) {
                    this.choppedBlocks.add(newBlocks.chopped);
                    let positionParams = {y: '-=30', ease: "power1.in", onComplete: () => this.choppedBlocks.remove(newBlocks.chopped)};
                    let rotateRandomness = 10;
                    let rotationParams = {
                        delay: 0.05,
                        x: newBlocks.plane == 'z' ? ((Math.random() * rotateRandomness) - (rotateRandomness / 2)) : 0.1,
                        z: newBlocks.plane == 'x' ? ((Math.random() * rotateRandomness) - (rotateRandomness / 2)) : 0.1,
                        y: Math.random() * 0.1,
                    };
                    if (newBlocks.chopped.position[newBlocks.plane] > newBlocks.placed.position[newBlocks.plane]) {
                        positionParams[newBlocks.plane] = '+=' + (40 * Math.abs(newBlocks.direction));
                    } else {
                        positionParams[newBlocks.plane] = '-=' + (40 * Math.abs(newBlocks.direction));
                    }
                    gsap.to(newBlocks.chopped.position, {duration: 1, ...positionParams});
                    gsap.to(newBlocks.chopped.rotation, {duration: 1, ...rotationParams});
                    
                }
                
                this.addBlock();
            }
            
            addBlock() {
                let lastBlock = this.blocks[this.blocks.length - 1];
                
                if (lastBlock && lastBlock.state == lastBlock.STATES.MISSED) {
                    return this.endGame();
                }
                
                this.scoreContainer.innerHTML = String(this.blocks.length - 1);
                
                let newKidOnTheBlock = new Block(lastBlock);
                this.newBlocks.add(newKidOnTheBlock.mesh);
                this.blocks.push(newKidOnTheBlock);

                this.stage.setCamera(this.blocks.length * 2);
                
                if (this.blocks.length >= 5) this.instructions.classList.add('hide');
            }
            
            endGame() {
                this.updateState(this.STATES.ENDED);
            }

            tick() {
                this.blocks[this.blocks.length - 1].tick();
                this.stage.render();
                requestAnimationFrame(() => {this.tick()});
            }
        }

        let game = new Game();
    </script>
</body>
</html>